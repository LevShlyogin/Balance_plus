from utils.main import run_comparison

def create_markdown_table(results):
    """Создает строку с таблицей в формате Markdown из списка результатов."""
    # Заголовок таблицы
    header = "| Метод              | Найденный X        | Итераций | Время (μs/запуск) | Итоговый A3_delt |"
    separator = "|:-------------------|:-------------------|:---------|:------------------|:-----------------|"
    
    # Строки таблицы
    rows = []
    for res in results:
        # Форматируем значения для красивого вывода
        method = f"**{res['Метод']}**" # Выделяем название метода жирным
        
        x_val = res['Найденный X']
        x_str = f"`{x_val:.8f}`" if isinstance(x_val, float) else str(x_val)
        
        iters_str = str(res['Итераций'])
        
        time_val = res['Время (μs/запуск)']
        time_str = f"{time_val:.4f}" if isinstance(time_val, float) else str(time_val)
        
        delta_val = res['Итоговый A3_delt']
        delta_str = f"{delta_val:.10f}" if isinstance(delta_val, float) else str(delta_val)
        
        # Собираем строку
        rows.append(f"| {method:<18} | {x_str:<18} | {iters_str:<8} | {time_str:<17} | {delta_str:<16} |")
        
    return "\n".join([header, separator] + rows)

def generate_report_file(results, filename="report.md"):
    """Генерирует полный файл отчета в формате Markdown."""
    
    table_md = create_markdown_table(results)

    # Используем многострочный f-string для создания шаблона всего файла
    report_content = f"""
# Сравнение методов решения

В этом файле представлены результаты сравнения производительности и точности трех методов для решения уравнения, заданного в `problem.py`.

**Цель:** найти такое значение `X`, при котором `A3_delt` будет равен **0.001**.

## Итоговая таблица

{table_md}

---

## Анализ и выводы

### 1. Аналитический метод
- **Скорость:** Абсолютный лидер. Решение находится за одну математическую операцию, без итераций.
- **Точность:** Максимально возможная, так как это прямое обращение формулы. Результат является эталоном.
- **Применимость:** Ограничена. Подходит только для тех задач, где можно вывести явную обратную функцию. В данном случае это было возможно.

### 2. Метод Дихотомии (Половинного деления)
- **Скорость:** Самый медленный из итерационных методов. Требует наибольшее количество итераций для достижения заданной точности.
- **Надежность:** Очень высокая. Метод гарантированно сходится, если на концах начального отрезка `[a, b]` значения функции имеют разный знак.
- **Применимость:** Широкая. Не требует производной, что делает его простым в реализации для сложных функций. Идеален, когда надежность важнее скорости.

### 3. Метод Ньютона (Метод касательных)
- **Скорость:** Очень быстрая сходимость (квадратичная). Ему потребовалось всего несколько итераций, чтобы достичь высокой точности.
- **Точность:** Очень высокая, сравнимая с аналитическим решением.
- **Применимость:** Требует вычисления производной функции. Сходимость сильно зависит от выбора начального приближения.

## Общий вывод

- **Аналитический метод** — идеальный вариант, если он существует.
- **Метод Ньютона** — лучший выбор для большинства практических задач, где требуется высокая скорость и известна производная.
- **Метод Дихотомии** — надежный "запасной" вариант, когда другие методы не работают или их сложно применить.
"""

    # Записываем все в файл
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report_content.strip())
        print(f"Отчет успешно сгенерирован в файле: {filename}")
    except IOError as e:
        print(f"Ошибка при записи файла: {e}")


if __name__ == "__main__":
    # 1. Получаем результаты, запустив симуляцию
    simulation_results = run_comparison()
    
    # 2. Генерируем отчет на основе этих результатов
    generate_report_file(simulation_results)